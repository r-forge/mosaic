\chapter{More About R}


  % location of 
    % not sure this does anything unless we use pgfSweave
         % keep.source probably disables this
          % use pdf for graphics
  % remove blank lines at beginning and end 
  % keeps formatting from original; allows ? to work


\begin{center}
\it
This material is more advanced than students in Intro Stats need, 

\vspace{-4mm}

but is good for more advanced students and instructors to know.
\end{center}

\DefineShortVerb{\&}

\section{Installing and Using Packages}

\R\ is open source software.  Its development is supported by
a team of core developers and a large community of users.
One way that users support
\R\ is by providing \term{packages} that contain data and functions
for a wide variety of tasks.  

\subsection{Installing packages from \cran}
If you need to install a package, most likely it will be on \cran.
Before a package can be used, it must be \term{installed} 
(once per computer) and 
\term{loaded} (once per \R\ session).  For example, to use &mosaic&:
\Rindex{install.packages()}%
\Rindex{require()}%

\begin{Schunk}
\begin{Sinput}
> install.packages("mosaic")   # fetch package from CRAN to local machine.
> require(mosaic)              # load the package so it can be used.
\end{Sinput}
\end{Schunk}

If you are running on a machine where you don't have privileges to
write to the default library location, you can install a personal 
copy of a package.  If the location of your personal library is 
first in &R_LIBS&, this will probably happen automatically.  If not,
you can specify the location manually:

\begin{Schunk}
\begin{Sinput}
> install.packages("mosaic",lib="~/R/library")
\end{Sinput}
\end{Schunk}
On a networked machine, be sure to use a different local directory for 
each platform since packages must match the platform.

Installing  packages on a Mac or PC is something you might like to do 
from the GUI since it will provide you with a list of packages from 
which you can select the ones of interest.
Binary packages have been precompiled for a 
particular platform and are generally faster and easier to set up, if they 
are available.  Source packages need to be compiled and built on your local
machine.  Usually this happens automatically -- provided you have all the 
necessary tools installed on your machine -- so the only disadvantage is the
extra time it takes to do the compiling and building.
%Most packages can be obtained as binary packages for PC's and Mac's.

\subsection{Installing other packages}

Occasionally you might find a package of interest that is not available via
a repository like \cran.  
Typically, if you find such a package, you will also find instructions
on how to install it.  If not, you can usually install directly from the 
zipped up package file.

\begin{Schunk}
\begin{Sinput}
> install.packages('some-package.tar.gz', 
+                   repos=NULL)           # use a file, not a repository
\end{Sinput}
\end{Schunk}



\subsection{Finding packages}
There are several ways to find packages
\begin{itemize}
  \item Ask your friends.
  \item Google:  Put `cran' in the search.
  \item Rseek:  \url{http://rseek.org} provides a search engine specifically
  designed to find information about \R.
  \item CRAN task views.

  A number of folks have put together task views that list a large
  number of packages and what they are good for.  They are 
  organized according to themes.  Here are a few examples
  of available task views:

  \UndefineShortVerb{\&}
  \begin{center}
    \begin{tabular}{lp{0.7\textwidth}}
    Bayesian &    Bayesian Inference \\
%    Cluster &   Cluster Analysis \& Finite Mixture Models \\
    Econometrics &   Computational Econometrics \\
%    Environmetrics &   Analysis of ecological and environmental data \\
    Finance &   Empirical Finance \\
    Genetics &   Statistical Genetics \\
    Graphics &   Graphic Displays,  Dynamic Graphics,
          Graphic Devices, and Visualization \\
%    gR &   gRaphical models in R \\
%    MachineLearning &   Machine Learning \& Statistical Learning \\
    Multivariate &   Multivariate Statistics \\
%    Psychometrics &   Psychometric Models and Methods \\
    SocialSciences &   Statistics for the Social Sciences \\
%    Spatial &   Analysis of Spatial Data \\
    \end{tabular}
  \end{center}
  \DefineShortVerb{\&}

  \item Biocunductor (\url{http://www.bioconductor.org/}) is another
  source of packages.

  \item \textit{R News} %(\url{http://cran.r-project.org/doc/Rnews/bib/Rnewsbib.html})
  (available via \cran)
  often has articles about new packages and their capabilities.

  \item Write your own.

  You can write your own packages, and it isn't that hard to do.
%  We won't cover this here.
\end{itemize}

\subsection{Some Useful Packages}
%Below are a few packages that may be of interest.
%In this
%section we present a few ``\R\ extras'' related to the material we have 
%covered so far.  The material is organized by the packages involved.

\subsubsection*{\texttt{mosaic}}

\subsubsection*{\texttt{Hmisc}}

\section{Some Workflow Suggestions}

In short: \emph{Think like a programmer.}  
\begin{itemize}
  \item Use \R\ interactively only to get documentation and for quick one-offs.
  \item Store your code in a file.  %# rather than entering it at the prompt.

\smallskip
  You can execute all the code in a file using 

\begin{Schunk}
\begin{Sinput}
> source("file.R") 
\end{Sinput}
\end{Schunk}
\Rstudio has options for executing some or all lines in a file, too. 
See the buttons in the panel for any \R\ script.  (You can create a new \R\ script
file in the main file menu.)

\smallskip\noindent
If you work at the interactive prompt in the console and later wish you had 
been putting your commands into a file, you can save your past commands with

\begin{Schunk}
\begin{Sinput}
> savehistory("someRCommandsIalmostLost.R")
\end{Sinput}
\end{Schunk}

You can selectively save portions of your history to a script file
using the History panel in \Rstudio.

\noindent
Then you can go back and edit the file.

  \item Use meaningful names.
  \item Write reusable functions.

  Learning to write your own functions will greatly increase your efficiency.
  (Stay tuned for details.)

  \item Comment your code.

  It's amazing what you can forget.  The comment character in \R\ is &#&.
  \myindex{comment character in R@comment character in {\sf R} (\texttt{\#})}%
  \Rindex{\#}%
\end{itemize}

\section{Working with Data}
\label{sec:MoreR-Data}%

\subsection{Data in {\sf R} packages}

Data sets in the \verb!datasets! package or any other loaded package
are available via the \verb!data()! function.  Usually, the use
of \verb!data()! is unnecessary, however, since \R\ will search
most loaded packages (they must have been created with the 
lazy-load option) for data sets without the explicit use of 
\verb!data()!.  The \verb!data()! function can be used to 
restore data after it has been modified or to control which package
is used when data sets with the same name appear in multiple packages.

\subsection{Loading data from flat files}
\R\ can read data from a number of file formats.  
The two most useful formats are &.csv& 
(comma separated values) and white space delimited.  
Excel and most statistical packages can read and write data in these 
formats, so these formats  make it easy to transfer data
between different software.  
\R\ provides &read.csv()& and &read.table()& to
\Rindex{read.csv()}%
\Rindex{read.table()}%
\Rindex{read.file()}%
handle these two situations.  They work nearly identically except for their 
default settings:
&read.csv()& assumes that the first line of the file contains
the variable names but &read.table()& assumes that the data begins on the first
line with no names for the variables,
and &read.table()& will ignore lines that begin with `&#&' but &read.csv()& will
not.

The default behavior can be overridden for each function, 
and there are a number of options that make it possible to 
read other file formats,
to omit a specified number of lines at the top of the file, etc.
If you are making the file yourself,
always include meaningful names in either file format. 


It is also possible to read data from a file located on the Internet.  
Simply replace the file name with a URL.
The data read below come from \cite{Tufte:2001:Visual}.
\authNoted{Check citation for Tufte.}%

\begin{Schunk}
\begin{Sinput}
> # need header=TRUE because there is a header line.
> # could also use read.file() without header=TRUE
> traffic <- 
+     read.table("http://www.calvin.edu/~rpruim/fastR/trafficTufte.txt", 
+     header=TRUE)
> traffic
\end{Sinput}
\begin{Soutput}
  year cn.deaths   ny   cn   ma   ri
1 1951       265 13.9 13.0 10.2  8.0
2 1952       230 13.8 10.8 10.0  8.5
3 1953       275 14.4 12.8 11.0  8.5
4 1954       240 13.0 10.8 10.5  7.5
5 1955       325 13.5 14.0 11.8 10.0
6 1956       280 13.4 12.1 11.0  8.2
7 1957       273 13.3 11.9 10.2  9.4
8 1958       248 13.0 10.1 11.8  8.6
9 1959       245 12.9 10.0 11.0  9.0
\end{Soutput}
\end{Schunk}

Notice the use of &<-& in the example above.  
This is the \rterm{assignment operator}
%\myindex{<-@\texttt{<-}|seeonly{assignment operator}}%
%\myindex{assignment operator}%
in \R.  
It can be used in either direction (&<-& or &->&).  In the first line of the 
example above, the results of &read.table()& are stored in a variable called 
&traffic&.  &traffic& is a \rterm{data frame}, \R's preferred container for
data.  (More about data types in \R\ as we go along.)



The &na.strings& argument can be used to specify
codes for missing values.  
The following can be useful for SAS output, for example:


For convenience \verb!mosaic! provides &read.file()& which uses the file name to
determine which of &read.table()& or &read.csv()& to use and sets the defaults
to &header=T&, &comment.char="#"&, and 
&na.strings=c('NA','','.','na')& for both file types.



\subsection{Manually typing in data}

If you need to enter a small data set by hand, 
the &scan()& function is quick and easy.
\Rindex{scan()}%
Individual values are separated by white space or new lines.  
A blank line is used to signal the end of the data.
By default, &scan()& is expecting decimal data (which it calls \rterm{double}, 
for double precision), but it is possible to tell &scan()& to expect something else,
like \rterm{character} data (i.e., text). 
There are other options for data types, but numerical and text data will usually suffice
for our purposes.  See &?scan& for more information and examples.

\begin{Rcode}
myData1 <- scan()
15 18
12
21 23 50 15

myData1

myData2 <- scan(what="character")
"red" "red" "orange" "green" "blue" "blue" "red"

myData2
\end{Rcode}

%
Be sure when using &scan()& that you remember to save your data somewhere.
Otherwise you will have to type it again.

\subsection{Creating data frames from vectors}

\Rindex{data.frame()}%
The &scan()& function puts data into a \rterm{vector}, not a \rterm{data frame}.  We can
build a \rterm{data frame} for our data as follows.

\begin{Schunk}
\begin{Sinput}
> myDataFrame <- data.frame(color=myData2,number=myData1)
> myDataFrame
\end{Sinput}
\begin{Soutput}
   color number
1    red     15
2    red     18
3 orange     12
4  green     21
5   blue     23
6   blue     50
7    red     15
\end{Soutput}
\end{Schunk}

\subsection{Getting data from mySQL data bases}

The &RMySQL& package allows direct access to data in MySQL data bases.
This can be convenient when dealing with subsets of very large data sets.
\Rindex{RMySQL}%
\myindex{SQL}%
%There is an \href{http://csg.sph.umich.edu/docs/R/rsql.html}{online document}
%describing this on the CSG website.


\subsection{Generating data}
\label{sec:generatingData}
\Rindex{rep()}%
\Rindex{seq()}%
\Rindex{c()}%
\Rindex{rnorm()}%
\Rindex{sample()}%

The following code shows a number of ways to generate data systematically.

\begin{Schunk}
\begin{Sinput}
> x <- 5:20; x                 # all integers in a range
\end{Sinput}
\begin{Soutput}
 [1]  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20
\end{Soutput}
\begin{Sinput}
> # structured sequences
> seq(0,50,by=5)               
\end{Sinput}
\begin{Soutput}
 [1]  0  5 10 15 20 25 30 35 40 45 50
\end{Soutput}
\begin{Sinput}
> seq(0,50,length=7)               
\end{Sinput}
\begin{Soutput}
[1]  0.000000  8.333333 16.666667 25.000000 33.333333 41.666667 50.000000
\end{Soutput}
\begin{Sinput}
> rep(1:5,each=3)
\end{Sinput}
\begin{Soutput}
 [1] 1 1 1 2 2 2 3 3 3 4 4 4 5 5 5
\end{Soutput}
\begin{Sinput}
> rep(1:5,times=3)
\end{Sinput}
\begin{Soutput}
 [1] 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5
\end{Soutput}
\begin{Sinput}
> c(1:5,10,3:5)                # c() concatenates vectors
\end{Sinput}
\begin{Soutput}
[1]  1  2  3  4  5 10  3  4  5
\end{Soutput}
\end{Schunk}

\R\ can also sample from several different distributions.

\begin{Schunk}
\begin{Sinput}
> rnorm(10,mean=10,sd=2)    # random draws from normal distribution
\end{Sinput}
\begin{Soutput}
 [1]  7.119645  9.532426  9.426323  9.764799  8.663652  8.402618  7.560445 10.375246 11.515347
[10]  8.632162
\end{Soutput}
\begin{Sinput}
> x <- 5:20                 # all integers in a range
> sample(x,size=5)          # random sample of size 5 from x (no replacement)
\end{Sinput}
\begin{Soutput}
[1] 13  5 17 10  9
\end{Soutput}
\end{Schunk}

Functions for sampling from other distributions include
&rbinom()&,
&rchisq()&,
&rt()&,
&rf()&,
&rhyper()&,
etc.
See Section~\ref{sec:DiscreteDistributions} for more information.



\subsection{Saving Data}
&write.table()& and &write.csv()& can be used to save data from \R\ into
delimited flat files.

\begin{Schunk}
\begin{Sinput}
> ddd <- data.frame(number=1:5,letter=letters[1:5])
> args(write.table)
\end{Sinput}
\begin{Soutput}
function (x, file = "", append = FALSE, quote = TRUE, sep = " ", 
    eol = "\n", na = "NA", dec = ".", row.names = TRUE, col.names = TRUE, 
    qmethod = c("escape", "double")) 
NULL
\end{Soutput}
\begin{Sinput}
> write.table(ddd,"ddd.txt")
> write.csv(ddd,"ddd.csv")
> # this system call should work on a Mac or Linux machine
> system("head -20 ddd.txt ddd.csv")
\end{Sinput}
\end{Schunk}



Data can also be saved in native \R\ format.  Saving data sets 
(and other \R\ objects) using &save()& has some advantages over other file formats:
\begin{itemize}
  \item 
  Complete information about the objects is saved, including attributes.
  \item
  Data saved this way takes less space and loads much more quickly.
  \item
  Multiple objects can be saved to and loaded from a single file.
\end{itemize}
The downside is that these files are only readable in \R.

\begin{Schunk}
\begin{Sinput}
> abc <- "abc"
> ddd <- data.frame(number=1:5,letter=letters[1:5])
> save(ddd,abc,file="ddd.zip")     # saves both objects in a single file
> load("ddd.zip")                  # loads them both
\end{Sinput}
\end{Schunk}

For more on importing and exporting data, especially from other
formats, see the 
%\href{http://cran.r-project.org/manuals.html}%
\textit{R Data Import/Export} manual available on \cran.

\subsection{Making Data Available to Students}

\authNote{Need to decide what to say about making data available to 
students.  Perhaps multiple methods? --RJP}%

\section{Primary \R\ Data Structures}

\subsection{Modes and other attributes} %factors, numeric, character, etc.}
In \R, data is stored in objects.  Each \rterm{object} 
has a \emph{name}, \emph{contents}, and also various \emph{attributes}.
Attributes are used to tell \R\ something about the kind
of data stored in an object and to store other auxiliary information.  
Two important attributes shared 
by all objects are \rterm{mode} and \rterm{length}.

\Rindex{mode()}%
\Rindex{attributes()}%
\Rindex{length()}%
\Rindex{attr()}%
\Rindex{[ ]}%

\begin{Schunk}
\begin{Sinput}
> w <- 2.5; x <- c(1,2); y <- "foo"; z <- TRUE; abc <- letters[1:3]
\end{Sinput}
\end{Schunk}

\begin{Schunk}
\begin{Sinput}
> mode(w); length(w)
\end{Sinput}
\begin{Soutput}
[1] "numeric"
\end{Soutput}
\begin{Soutput}
[1] 1
\end{Soutput}
\begin{Sinput}
> mode(x); length(x)
\end{Sinput}
\begin{Soutput}
[1] "numeric"
\end{Soutput}
\begin{Soutput}
[1] 2
\end{Soutput}
\begin{Sinput}
> mode(y); length(y)
\end{Sinput}
\begin{Soutput}
[1] "character"
\end{Soutput}
\begin{Soutput}
[1] 1
\end{Soutput}
\end{Schunk}

\begin{Schunk}
\begin{Sinput}
> y[1]; y[2]             # not an error to ask for y[2]
\end{Sinput}
\begin{Soutput}
[1] "foo"
\end{Soutput}
\begin{Soutput}
[1] NA
\end{Soutput}
\begin{Sinput}
> mode(z); length(z)
\end{Sinput}
\begin{Soutput}
[1] "logical"
\end{Soutput}
\begin{Soutput}
[1] 1
\end{Soutput}
\begin{Sinput}
> abc
\end{Sinput}
\begin{Soutput}
[1] "a" "b" "c"
\end{Soutput}
\begin{Sinput}
> mode(abc); length(abc)
\end{Sinput}
\begin{Soutput}
[1] "character"
\end{Soutput}
\begin{Soutput}
[1] 3
\end{Soutput}
\begin{Sinput}
> abc[3]
\end{Sinput}
\begin{Soutput}
[1] "c"
\end{Soutput}
\end{Schunk}

Each of the objects in the example above is a \rterm{vector}, an ordered container
of values that all have the same mode.%
\footnote{
There are other modes in addition to the ones shown here, including
\verb&complex& (for complex numbers), 
\verb&function&, \verb&list&, \verb&call&, and \verb&expression&.}
The &c()& function concatenates vectors (or lists).
Notice that &w&, &y&, and &z& are 
vectors of length~1.  Missing values are coded as &NA& (not available).  Asking
for an entry ``off the end'' of a vector returns &NA&.
Assigning a value ``off the end'' of a vector results in the vector being
lengthened so that the new value can be stored in the appropriate location.

There are important ways that \R\ has 
been optimized to work with vectors since they correspond to variables 
(in the sense of statistics).
For categorical data, a \rterm{factor} is a special type of vector that includes
an additional attribute called \emph{levels}.  
A factor can be ordered or unordered (which can affect how statistics
are done and graphs are made) and its elements can have mode
&numeric& or &character&.

A \rterm{list} is similar to a vector, but its elements may be of different 
modes (including &list&, &vector&, etc.).
A \rterm{data frame} is a list of vectors (or factors), 
each of the same length, but not necessarily of the same mode.  
This is \R's primary way of storing data sets.
An \rterm{array} is a multi-dimensional table of values that all have the same 
mode.  A \rterm{matrix} is a 2-dimensional array.
\Rindex{matrix()}%

\Rindex{[ ]}%
\Rindex{[[ ]]}%
The access operators (&[ ]& for vectors, matrices, arrays, and data frames,
and  &[[ ]]& for lists) are actually \emph{functions} in \R.
This has some important consequences:
\begin{itemize}
  \item Accessing elements is slower than in a language like C/C++
  where access is done by pointer arithmetic.
  \item
  These functions also have named arguments, so you can see code like the following
\end{itemize}

\begin{Schunk}
\begin{Sinput}
> xm <- matrix(1:16, nrow=4); xm
\end{Sinput}
\begin{Soutput}
     [,1] [,2] [,3] [,4]
[1,]    1    5    9   13
[2,]    2    6   10   14
[3,]    3    7   11   15
[4,]    4    8   12   16
\end{Soutput}
\begin{Sinput}
> xm[5]
\end{Sinput}
\begin{Soutput}
[1] 5
\end{Soutput}
\begin{Sinput}
> xm[,2]                   # this is 1 dimensional (a vector)
\end{Sinput}
\begin{Soutput}
[1] 5 6 7 8
\end{Soutput}
\begin{Sinput}
> xm[,2,drop=FALSE]        # this is 2 dimensional (still a matrix)
\end{Sinput}
\begin{Soutput}
     [,1]
[1,]    5
[2,]    6
[3,]    7
[4,]    8
\end{Soutput}
\end{Schunk}

Many objects have a \rterm{dim attribute} that stores the dimension
of the object.  You can change it to change the shape (or even the number
of dimensions) of a vector, matrix, or array.
You can see all of the non-intrinsic attributes (mode and 
length are intrinsic) using &attributes()&, 
and you can set attributes (including 
new ones you make up) using &attr()&.  Some attributes, like dimension,
have special functions for accessing or setting.
The \verb!dim()! function returns the dimensions of an object
as a vector.  Alternatively the number of rows and columns can be 
obtained using \verb!nrow()! and \verb!ncol()!.

\Rindex{dim()}%
\Rindex{nrow()}%
\Rindex{ncol()}%
\Rindex{letters[]}%
\Rindex{names()}%
\Rindex{row.names()}%
\Rindex{attr()}%
\Rindex{attributes()}%

\begin{Schunk}
\begin{Sinput}
> ddd <- data.frame(number=1:5,letter=letters[1:5])
> attributes(ddd)
\end{Sinput}
\begin{Soutput}
$names
[1] "number" "letter"

$row.names
[1] 1 2 3 4 5

$class
[1] "data.frame"
\end{Soutput}
\begin{Sinput}
> dim(ddd)
\end{Sinput}
\begin{Soutput}
[1] 5 2
\end{Soutput}
\begin{Sinput}
> nrow(ddd)
\end{Sinput}
\begin{Soutput}
[1] 5
\end{Soutput}
\begin{Sinput}
> ncol(ddd)
\end{Sinput}
\begin{Soutput}
[1] 2
\end{Soutput}
\begin{Sinput}
> names(ddd)
\end{Sinput}
\begin{Soutput}
[1] "number" "letter"
\end{Soutput}
\begin{Sinput}
> row.names(ddd)
\end{Sinput}
\begin{Soutput}
[1] "1" "2" "3" "4" "5"
\end{Soutput}
\begin{Sinput}
> row.names(ddd) <- c("Abe","Betty","Claire","Don","Ethel")
> ddd                 # row.names affects how a data.frame prints
\end{Sinput}
\begin{Soutput}
       number letter
Abe         1      a
Betty       2      b
Claire      3      c
Don         4      d
Ethel       5      e
\end{Soutput}
\end{Schunk}

\subsection{What \texttt{is} it?}

\R\ provides a number of functions for testing the mode or class of an object.

\begin{Schunk}
\begin{Sinput}
> mode(xm); class(xm)
\end{Sinput}
\begin{Soutput}
[1] "numeric"
\end{Soutput}
\begin{Soutput}
[1] "matrix"
\end{Soutput}
\begin{Sinput}
> c(is.numeric(xm), is.character(xm), is.integer(xm), is.logical(xm))
\end{Sinput}
\begin{Soutput}
[1]  TRUE FALSE  TRUE FALSE
\end{Soutput}
\begin{Sinput}
> c(is.vector(xm), is.matrix(xm), is.array(xm))
\end{Sinput}
\begin{Soutput}
[1] FALSE  TRUE  TRUE
\end{Soutput}
\end{Schunk}


\subsection{Changing modes and attributes}
\Rindex{is.numeric()}%
\Rindex{as.numeric()}%
\Rindex{is.integer()}%
\Rindex{as.integer()}%

If \R\ is expecting an object of a certain mode or class but gets 
something else, it will often try to \rterm{coerce} the object to meet 
its expectations.  You
can also coerce things manually using one of the many &as.???()& functions.

\begin{Schunk}
\begin{Sinput}
> apropos("^as\\.")[1:10]      # just a small sample
\end{Sinput}
\begin{Soutput}
 [1] "as.array"               "as.array.default"       "as.call"               
 [4] "as.character"           "as.character.condition" "as.character.Date"     
 [7] "as.character.default"   "as.character.error"     "as.character.factor"   
[10] "as.character.hexmode"  
\end{Soutput}
\begin{Sinput}
> # convert numbers to strings (this drops attributes)
> as.character(xm)             
\end{Sinput}
\begin{Soutput}
 [1] "1"  "2"  "3"  "4"  "5"  "6"  "7"  "8"  "9"  "10" "11" "12" "13" "14" "15" "16"
\end{Soutput}
\begin{Sinput}
> # convert matrix to vector
> as.vector(xm)
\end{Sinput}
\begin{Soutput}
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16
\end{Soutput}
\begin{Sinput}
> as.logical(xm)
\end{Sinput}
\begin{Soutput}
 [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE
\end{Soutput}
\begin{Sinput}
> alpha <- c("a","1","b","0.5")    
> mode(alpha)
\end{Sinput}
\begin{Soutput}
[1] "character"
\end{Soutput}
\begin{Sinput}
> as.numeric(alpha)      # can't do the coersion, so NAs are introduced
\end{Sinput}
\begin{Soutput}
[1]  NA 1.0  NA 0.5
\end{Soutput}
\begin{Sinput}
> as.integer(alpha)      # notice coersion of 0.5 to 0
\end{Sinput}
\begin{Soutput}
[1] NA  1 NA  0
\end{Soutput}
\end{Schunk}

\section{More About Vectors}
Vectors are so important in \R\ that they deserve some additional discussion.
In Section~\ref{sec:generatingData} we learned how to generate some simple
vectors.  Here we will learn about some of the operations and functions
that can be applied to vectors.

\subsection{Vectorized functions}

Many \R\ functions and operations are ``vectorized'' and can be applied
not just to an individual value but to an entire vector, in which case
they are applied componentwise and return a vector of transformed values.  
Most traditional mathematics functions are available and work this way.
\Rindex{mean()}%
\Rindex{sd()}%
\Rindex{var()}%
\Rindex{median()}%
\Rindex{log()}%

\begin{Schunk}
\begin{Sinput}
> x <- 1:5; y <- seq(10,60,by=10); z <- rnorm(10); x; y
\end{Sinput}
\begin{Soutput}
[1] 1 2 3 4 5
\end{Soutput}
\begin{Soutput}
[1] 10 20 30 40 50 60
\end{Soutput}
\begin{Sinput}
> y + 1
\end{Sinput}
\begin{Soutput}
[1] 11 21 31 41 51 61
\end{Soutput}
\begin{Sinput}
> x * 10
\end{Sinput}
\begin{Soutput}
[1] 10 20 30 40 50
\end{Soutput}
\begin{Sinput}
> x < 3
\end{Sinput}
\begin{Soutput}
[1]  TRUE  TRUE FALSE FALSE FALSE
\end{Soutput}
\begin{Sinput}
> x^2
\end{Sinput}
\begin{Soutput}
[1]  1  4  9 16 25
\end{Soutput}
\begin{Sinput}
> log(x); log(x, base=10)            # natural and base 10 logs
\end{Sinput}
\begin{Soutput}
[1] 0.0000000 0.6931472 1.0986123 1.3862944 1.6094379
\end{Soutput}
\begin{Soutput}
[1] 0.0000000 0.3010300 0.4771213 0.6020600 0.6989700
\end{Soutput}
\end{Schunk}

\noindent
Vectors can be combined into a matrix using &rbind()& or &cbind()&.  
This can facilitate side-by-side comparisons.
\Rindex{rbind()}%
\Rindex{cbind()}%
\Rindex{round()}%
\Rindex{signif()}%

\begin{Schunk}
\begin{Sinput}
> # compare round() and signif() by binding rowwise into matrix
> rbind(round(z,digits=2), signif(z,digits=2))   
\end{Sinput}
\begin{Soutput}
      [,1]  [,2]  [,3]  [,4] [,5] [,6]  [,7] [,8]  [,9] [,10]
[1,] -0.39 -0.37 -0.88 -0.53 0.33 0.16 -0.78 0.26 -0.42 -0.45
[2,] -0.39 -0.37 -0.88 -0.53 0.33 0.16 -0.78 0.26 -0.42 -0.45
\end{Soutput}
\end{Schunk}


\subsection{Functions that act on vectors as vectors}

Other functions, including many statistical functions,
are designed to work on the vector as a vector.  Often these 
return a single value (technically a vector of length~1), but
other return types are used as appropriate.

\begin{Schunk}
\begin{Sinput}
> x <- 1:10; z <- rnorm(100)
> mean(z); sd(z); var(z); median(z)  # basic statistical functions
\end{Sinput}
\begin{Soutput}
[1] -0.05871836
\end{Soutput}
\begin{Soutput}
[1] 1.058351
\end{Soutput}
\begin{Soutput}
[1] 1.120107
\end{Soutput}
\begin{Soutput}
[1] -0.08751377
\end{Soutput}
\begin{Sinput}
> range(z)                           # range returns a vector of length 2
\end{Sinput}
\begin{Soutput}
[1] -2.860879  2.798102
\end{Soutput}
\begin{Sinput}
> sum(x); prod(x)                         # sums and products
\end{Sinput}
\begin{Soutput}
[1] 55
\end{Soutput}
\begin{Soutput}
[1] 3628800
\end{Soutput}
\end{Schunk}

\begin{Schunk}
\begin{Sinput}
> z <- rnorm(5); z
\end{Sinput}
\begin{Soutput}
[1] -1.8732048 -0.8792704 -1.1625320  0.7584718  1.1182349
\end{Soutput}
\begin{Sinput}
> sort(z); rank(z); order(z)              # sort, rank, order
\end{Sinput}
\begin{Soutput}
[1] -1.8732048 -1.1625320 -0.8792704  0.7584718  1.1182349
\end{Soutput}
\begin{Soutput}
[1] 1 3 2 4 5
\end{Soutput}
\begin{Soutput}
[1] 1 3 2 4 5
\end{Soutput}
\begin{Sinput}
> rev(x)                                  # reverse x
\end{Sinput}
\begin{Soutput}
 [1] 10  9  8  7  6  5  4  3  2  1
\end{Soutput}
\end{Schunk}

\begin{Schunk}
\begin{Sinput}
> diff(x)                                 # pairwise differences
\end{Sinput}
\begin{Soutput}
[1] 1 1 1 1 1 1 1 1 1
\end{Soutput}
\begin{Sinput}
> cumsum(x)                               # cumulative sum
\end{Sinput}
\begin{Soutput}
 [1]  1  3  6 10 15 21 28 36 45 55
\end{Soutput}
\begin{Sinput}
> cumprod(x)                              # cumulative product
\end{Sinput}
\begin{Soutput}
 [1]       1       2       6      24     120     720    5040   40320  362880 3628800
\end{Soutput}
\begin{Sinput}
> sum(x); prod(x)                         # sums and products
\end{Sinput}
\begin{Soutput}
[1] 55
\end{Soutput}
\begin{Soutput}
[1] 3628800
\end{Soutput}
\end{Schunk}
\label{r:sumprod}%

Whether a function is vectorized or treats a vector as a unit
depends on its implementation.  Usually, things are implemented 
the way you would expect.  Occasionally you may discover a function
that you wish were vectorized and is not.    
When writing your own functions, give some thought to whether they
should be vectorized, and test them with vectors of length greater than 1
to make sure you get the intended behavior.
\Rindex{sum()}%
\Rindex{prod()}%
\Rindex{cumsum()}%
\Rindex{cumprod()}%
\Rindex{cummin()}%
\Rindex{cummax()}%
\Rindex{diff()}%
\Rindex{rev()}%
\Rindex{sort()}%
\Rindex{rank()}%
\Rindex{order()}%
\Rindex{which()}%
\Rindex{any()}%
\Rindex{unique()}%
\Rindex{table()}%
\Rindex{paste()}%
\Rindex{na.omit()}%
\Rindex{pmin()}%
\Rindex{pmax()}%


Some additional useful functions are included in Table~\ref{table:useful-functions}.

\begin{table}
\caption{Some useful \R\ functions.}
\label{table:useful-functions}%
\begin{center}
\UndefineShortVerb{\&}
  \begin{longtable}{|p{1.2in}|p{3.5in}|}
  \hline
  \verb!cumsum()!

  \verb!cumprod()!

  \verb!cummin()!

  \verb!cummax()!
  &
  Returns vector of cumulative sums, products, minima, or maxima.
  \\ \hline
  \verb!pmin(x,y,...)!

  \verb!pmax(x,y,...)!
  &
  Returns vector of parallel minima or maxima where $i$th element is
  max or min of \verb!x[i]!, \verb!y[i]!, \dots.
  \\ \hline
  \verb!which(x)! 
  &
  Returns a vector of indices of elements of \verb!x! that are true.
  Typical use: \verb!which(y > 5)! returns the indices where elements
  of \verb&y& are larger than 5.
  \\ \hline
  \verb!any(x)! 
  &
  Returns a \verb!logical! indicating whether any elements of \verb!x! 
  are true.
  Typical use: \verb!if ( any(y > 5) ) { ...}!.
  \\ \hline
  \verb!na.omit(x)! & Returns a vector with missing values removed.
  \\ \hline
  \verb!unique(x)! & Returns a vector with repeated values removed.
  \\ \hline
  \verb!table(x)! & Returns a table of counts of the number of 
  occurrences of each value in \verb!x!.  The table is similar
  to a vector with names indicating the values, but it is not a vector.
  \\ \hline
  \verb!paste(x,y,...,!
  
  \verb!  sep=" ")! 
  & Pastes \verb!x! and \verb!y! together
  componentwise (as strings) with \verb!sep! between elements.
  Recycling applies.
  \\ \hline
  \end{longtable}
\DefineShortVerb{\&}
\end{center}
\end{table}


\subsection{Recycling}
\myindex{recycling}%
When vectors operate on each other, the operation is done componentwise, 
recycling the shorter vector to match the length of the longer.

\begin{Schunk}
\begin{Sinput}
> x <- 1:5; y <- seq(10,70,by=10)
> x + y
\end{Sinput}
\begin{Soutput}
[1] 11 22 33 44 55 61 72
\end{Soutput}
\end{Schunk}

\noindent
In fact, this is exactly how things like &x + 1& actually work.
If &x& is a vector of length $n$, then \verb!1! (a vector of length 1) is 
first recycled into a vector of length $n$; then the two vectors are
added componentwise.
Some vectorized functions that take multiple vectors as arguments
will first use recycling to make them the same length.

\subsection{Accessing elements of vectors}
\R\ allows for some very interesting and useful methods for accessing
elements of a vector that combine the ideas above.
First, recall that the &[ ]& operator is actually a function.
Furthermore, it is vectorized.

\begin{Schunk}
\begin{Sinput}
> x <- seq(2,20,by=2)
> x[1:5]; x[c(1,4,7)]
\end{Sinput}
\begin{Soutput}
[1]  2  4  6  8 10
\end{Soutput}
\begin{Soutput}
[1]  2  8 14
\end{Soutput}
\end{Schunk}

&[ ]& accepts &logicals& as arguments well.
The boolean values (recycled, if necessary)
are used to select or deselect elements of the vector.

\begin{Schunk}
\begin{Sinput}
> x <- seq(2,20,by=2)
> x[c(TRUE,TRUE,FALSE)]        # skips every third element (recycling!)
\end{Sinput}
\begin{Soutput}
[1]  2  4  8 10 14 16 20
\end{Soutput}
\begin{Sinput}
> x[x > 10]                    # more typical use of boolean in selection
\end{Sinput}
\begin{Soutput}
[1] 12 14 16 18 20
\end{Soutput}
\end{Schunk}

\noindent
Negative indices are used to omit elements.

\begin{Schunk}
\begin{Sinput}
> x <- seq(2,20,by=2)
> x[c(TRUE,TRUE,FALSE)]        # skips every third element (recycling!)
\end{Sinput}
\begin{Soutput}
[1]  2  4  8 10 14 16 20
\end{Soutput}
\begin{Sinput}
> x[x > 10]                    # more typical use of boolean in selection
\end{Sinput}
\begin{Soutput}
[1] 12 14 16 18 20
\end{Soutput}
\end{Schunk}

\noindent
Here are some more examples.
\Rindex{toupper()}%
\Rindex{tolower()}%

\begin{Schunk}
\begin{Sinput}
> notes <- toupper(letters[1:7]); a <- 1:5; b <- seq(10,100,by=10)
> toupper(letters[5:10])                
\end{Sinput}
\begin{Soutput}
[1] "E" "F" "G" "H" "I" "J"
\end{Soutput}
\begin{Sinput}
> paste(letters[1:5],1:3,sep='-')
\end{Sinput}
\begin{Soutput}
[1] "a-1" "b-2" "c-3" "d-1" "e-2"
\end{Soutput}
\begin{Sinput}
> a+b
\end{Sinput}
\begin{Soutput}
 [1]  11  22  33  44  55  61  72  83  94 105
\end{Soutput}
\begin{Sinput}
> (a+b)[ a+b > 50]
\end{Sinput}
\begin{Soutput}
[1]  55  61  72  83  94 105
\end{Soutput}
\begin{Sinput}
> length((a+b)[a+b > 50])
\end{Sinput}
\begin{Soutput}
[1] 6
\end{Soutput}
\begin{Sinput}
> table(a+b > 50)
\end{Sinput}
\begin{Soutput}
FALSE  TRUE 
    4     6 
\end{Soutput}
\end{Schunk}

%\includepdf[pages=35-39,frame]{Paradis-rdebuts_en.pdf}

%\includepdf[pages=36-37,landscape,rotateoversize,turn=false,nup=1x2,frame]{Paradis-rdebuts_en.pdf}

\section{Manipulating Data}
\label{sec:manipulatingData}%

%\subsection{Cross Tabulation with \texttt{xtabs()}}
%\subsection{\texttt{aggregate()} and \texttt{Hmisc::summary()}}
\subsection{Adding new variables to a data frame}

We can add additional variables to an existing data frame by simple assignment.
It is an error to add a vector of the wrong length.

\begin{Schunk}
\begin{Sinput}
> iris$SLength <- cut(iris$Sepal.Length,4:8)
\end{Sinput}
\end{Schunk}

\begin{Schunk}
\begin{Sinput}
> summary(iris)
\end{Sinput}
\begin{Soutput}
  Sepal.Length    Sepal.Width     Petal.Length    Petal.Width          Species    SLength  
 Min.   :4.300   Min.   :2.000   Min.   :1.000   Min.   :0.100   setosa    :50   (4,5]:32  
 1st Qu.:5.100   1st Qu.:2.800   1st Qu.:1.600   1st Qu.:0.300   versicolor:50   (5,6]:57  
 Median :5.800   Median :3.000   Median :4.350   Median :1.300   virginica :50   (6,7]:49  
 Mean   :5.843   Mean   :3.057   Mean   :3.758   Mean   :1.199                   (7,8]:12  
 3rd Qu.:6.400   3rd Qu.:3.300   3rd Qu.:5.100   3rd Qu.:1.800                             
 Max.   :7.900   Max.   :4.400   Max.   :6.900   Max.   :2.500                             
\end{Soutput}
\end{Schunk}
\Rindex{summary()}


\subsection{Slicing and dicing}
\authNote{This section could probably be improved/expanded --rjp}%


&reshape()& provides a flexible way to change the arrangement of data.  
\Rindex{reshape()}%
It was designed for converting between long and wide versions of 
time series data and its arguments are named with that in mind.

A common situation is when we want to convert from a wide form to a 
long form because of a change in perspective about what a unit of 
observation is.  For example,

\begin{Schunk}
\begin{Sinput}
> traffic
\end{Sinput}
\begin{Soutput}
  year cn.deaths   ny   cn   ma   ri
1 1951       265 13.9 13.0 10.2  8.0
2 1952       230 13.8 10.8 10.0  8.5
3 1953       275 14.4 12.8 11.0  8.5
4 1954       240 13.0 10.8 10.5  7.5
5 1955       325 13.5 14.0 11.8 10.0
6 1956       280 13.4 12.1 11.0  8.2
7 1957       273 13.3 11.9 10.2  9.4
8 1958       248 13.0 10.1 11.8  8.6
9 1959       245 12.9 10.0 11.0  9.0
\end{Soutput}
\begin{Sinput}
> reshape(traffic[,-2], idvar="year",ids=row.names(traffic),
+         times=names(traffic)[3:6],timevar="state",
+         varying=list(names(traffic)[3:6]),
+         v.names="deathRate",
+         direction="long") -> longTraffic
> head(longTraffic)
\end{Sinput}
\begin{Soutput}
        year state deathRate
1951.ny 1951    ny      13.9
1952.ny 1952    ny      13.8
1953.ny 1953    ny      14.4
1954.ny 1954    ny      13.0
1955.ny 1955    ny      13.5
1956.ny 1956    ny      13.4
\end{Soutput}
\end{Schunk}

In simpler cases, &stack()& or &unstack()& may suffice.
\verb!Hmisc! also provides \verb!reShape()! as an alternative 
to \verb!reshape()!.
\Rindex{stack()}%
\Rindex{unstack()}%

\subsection{Simple Relational Database Operations}

\subsubsection*{Example: Grades/Courses}

Using the grade/courses database, show how to combine data from
different data frames. [DTK]

\subsubsection{Example: Merging Genotype and Phenotype Data}
%\label{example:fusion1-glm1}%
%\myindex{FUSION|exampleidx}%
%\myindex{logistic regression}%
The \verb!fusion1! data frame in the \verb!fastR! package contains
genotypes of subjects from the FUSION study of the genetics of type 
2 diabetes.
The \verb!pheno! data frame contains phenotypes (including T2D 
case/control status) for an intersecting set of individuals.
We can merge these together to explore the association between
genotypes and phenotypes using \verb!merge()!.
\pagebreak

%\Rindex{merge()}%
\begin{Schunk}
\begin{Sinput}
> require(fastR)
> head(fusion1,3)
\end{Sinput}
\begin{Soutput}
     id     marker markerID allele1 allele2 genotype Adose Cdose Gdose Tdose
1  9735 RS12255372        1       3       3       GG     0     0     2     0
2 10158 RS12255372        1       3       3       GG     0     0     2     0
3  9380 RS12255372        1       3       4       GT     0     0     1     1
\end{Soutput}
\begin{Sinput}
> head(pheno,3)
\end{Sinput}
\begin{Soutput}
    id     t2d      bmi sex      age smoker chol waist weight height       whr sbp dbp
1 1002    case 32.85994   F 70.76438 former 4.57 112.0   85.6  161.4 0.9867841 135  77
2 1009    case 27.39085   F 53.91896  never 7.32  93.5   77.4  168.1 0.9396985 158  88
3 1012 control 30.47048   M 53.86161 former 5.02 104.0   94.6  176.2 0.9327354 143  89
\end{Soutput}
\end{Schunk}

\begin{Schunk}
\begin{Sinput}
> # merge fusion1 and pheno keeping only id's that are in both
> fusion1m <- merge(fusion1, pheno, by='id', all.x=FALSE, all.y=FALSE)
\end{Sinput}
\end{Schunk}
\begin{Schunk}
\begin{Sinput}
> head(fusion1m, 3)
\end{Sinput}
\begin{Soutput}
    id     marker markerID allele1 allele2 genotype Adose Cdose Gdose Tdose     t2d      bmi sex
1 1002 RS12255372        1       3       3       GG     0     0     2     0    case 32.85994   F
2 1009 RS12255372        1       3       3       GG     0     0     2     0    case 27.39085   F
3 1012 RS12255372        1       3       3       GG     0     0     2     0 control 30.47048   M
       age smoker chol waist weight height       whr sbp dbp
1 70.76438 former 4.57 112.0   85.6  161.4 0.9867841 135  77
2 53.91896  never 7.32  93.5   77.4  168.1 0.9396985 158  88
3 53.86161 former 5.02 104.0   94.6  176.2 0.9327354 143  89
\end{Soutput}
\begin{Sinput}
> xtabs(~t2d + Gdose + marker, fusion1m)
\end{Sinput}
\begin{Soutput}
, , marker = RS12255372

         Gdose
t2d         0   1   2
  case     48 375 737
  control  27 309 835
\end{Soutput}
\end{Schunk}

\section{Functions in \R} %{An introduction to writing functions}
\label{sec:writingFunctions}
\myindex{functions in {\sf R}}%

%To really customize a &lattice& plot -- and for many other applications in \R\ -- 
%you need to learn how to use the &panel& argument,
%which means you need to learn how to write functions.
Functions in \R\ have several components:
\begin{itemize}
  \item a \rterm{name} (like &histogram&)\footnote{Actually, it is possible to define 
	functions without naming them; and for short functions that are only needed once,
	this can actually be useful.}
  \item
	an ordered list of named \rterm{arguments} that serve as inputs to the function
	\myindex{argument of an R function@argument of an {\sf R} function}%

	These are matched first by name and then by order to the values supplied by
	the call to the function.  This is why we don't always include the argument name
	in our function calls.  On the other hand, the availability of names means that
	we don't have to remember the order in which arguments are listed.

	Arguments often have \rterm{default values} which are used if no value is 
	supplied in the function call.
  \item
	a \rterm{return value}

	This is the output of the function.  It can be assigned to a variable
	using the assignment operator (&=&, &<-&, or &->&).
	\Rindex{->}%
	\Rindex{<-}%
	\Rindex{=}%

  \item
	\rterm{side effects}
	
	A function may do other things (like make a graph or set some preferences) 
	that are not necessarily part of the return value.

\end{itemize}
When you read the help pages for an \R\ function, you will see that they are organized
in sections related to these components.  
The list of arguments appears in the \rterm{Usage} section along 
with any default values.  Details about how the arguments are used appear in the 
\rterm{Arguments} section.  The return value is listed in the \rterm{Value} section.
Any side effects are typically mentioned in the \rterm{Details} section.  

Now let's try writing our own function.  Suppose you frequently wanted to compute
the mean, median, and standard deviation of a distribution.  You could make 
a function to do all three to save some typing.  
Let's name our function  &favstats()&.  
&favstats()& will have one argument, which we are assuming will be a vector of
numeric values.%
\Rindex{favstats()}%
\Rindex{function()}%
\footnote{There are ways to check the \rterm{class} of an argument
to see if it is a data frame, a vector, numeric, etc.  A really robust function
should check to make sure that the values supplied to the arguments are of appropriate
types.}
Here is how we could define it:
\Rindex{favstats()}%

\begin{Schunk}
\begin{Sinput}
> favstats <- function(x) {
+     mean(x)
+     median(x)
+     sd(x)
+ }
> favstats((1:20)^2)
\end{Sinput}
\begin{Soutput}
[1] 127.9023
\end{Soutput}
\end{Schunk}

The first line says that we are defining a function called &favstats()& with one
argument, named &x&.  The lines surrounded by curly braces give the code
to be executed when the function is called.  So our function computes 
the mean, then the median, then the standard deviation of its argument.

But as you see, this doesn't do exactly what we wanted.  So what's going on?  
The value returned by the last line of a function is (by default) returned
by the function to its calling environment, where it is (by default) printed
to the screen so you can see it.  In our case, we computed the mean, median,
and standard deviation, but only the standard deviation is being returned 
by the function and hence displayed.  So this function is just an inefficient
version of &sd()&.  That isn't really what we wanted.

We can use &print()& to print out things along the way if we like.

\begin{Schunk}
\begin{Sinput}
> favstats <- function(x) {
+     print(mean(x))
+     print(median(x))
+     print(sd(x))
+ }
> favstats((1:20)^2)
\end{Sinput}
\begin{Soutput}
[1] 143.5
[1] 110.5
[1] 127.9023
\end{Soutput}
\end{Schunk}

Alternatively, we could use a combination of \verb!cat()! and \verb!paste()!, which
would give us more control over how the output is displayed.
\Rindex{cat()}%
\Rindex{paste()}%

\begin{Schunk}
\begin{Sinput}
> altfavstats <- function(x) {
+     cat(paste("  mean:", format(mean(x),4),"\n"))
+     cat(paste(" edian:", format(median(x),4),"\n"))
+     cat(paste("    sd:", format(sd(x),4),"\n"))
+ }
> altfavstats((1:20)^2)
\end{Sinput}
\begin{Soutput}
  mean: 143.5 
 edian: 110.5 
    sd: 127.9023 
\end{Soutput}
\end{Schunk}
Either of these methods will allow us to see all three values, 
but if we try to store them \dots

\begin{Schunk}
\begin{Sinput}
> temp <- favstats((1:20)^2)
\end{Sinput}
\begin{Soutput}
[1] 143.5
[1] 110.5
[1] 127.9023
\end{Soutput}
\begin{Sinput}
> temp
\end{Sinput}
\begin{Soutput}
[1] 127.9023
\end{Soutput}
\end{Schunk}
A function in \R\ can only have one return value, and by default it is the 
value of the last line in the function.  
In the preceding example we only get the standard deviation since 
that is the value we calculated last.

We would really like the function to return all three summary statistics.  
Our solution will be to
store all three in a vector and return the vector.%
\footnote{If the values had not all been of the same mode, we 
could have used a list instead.}

\begin{Schunk}
\begin{Sinput}
> favstats <- function(x) {
+ 	c(mean(x),median(x), sd(x))
+ }
> favstats((1:20)^2)
\end{Sinput}
\begin{Soutput}
[1] 143.5000 110.5000 127.9023
\end{Soutput}
\end{Schunk}
Now the only problem is that we have to remember which number is which.
We can fix this by giving names to the slots in our vector.
While we're at it, let's add a few more favorites to the list.
We'll also add an explicit &return()&.
\Rindex{return()}%

\begin{Schunk}
\begin{Sinput}
> favstats <- function(x) {
+     result <- c(min(x),max(x),mean(x),median(x), sd(x))
+     names(result) <- c("min","max","mean","median","sd")
+     return(result)
+ }
> favstats((1:20)^2)
\end{Sinput}
\begin{Soutput}
     min      max     mean   median       sd 
  1.0000 400.0000 143.5000 110.5000 127.9023 
\end{Soutput}
\begin{Sinput}
> summary(Sepal.Length~Species,data=iris,fun=favstats)
\end{Sinput}
\begin{Soutput}
 Length   Class    Mode 
      3 formula    call 
\end{Soutput}
\end{Schunk}

Notice how nicely this works with &summary()& from the &Hmisc& package.
You can, of course, define your own favorite function to use with &summary()&.
\Rindex{favstats()}%
The &favstats()& function in &fastR& includes the quartiles, mean, standard
deviation, and variance.
\Rindex{summary()}%
\Rindex{Hmisc}%



\UndefineShortVerb{\&}
